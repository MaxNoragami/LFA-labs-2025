# Topic: Parser & Building an Abstract Syntax Tree
****
### Course: Formal Languages & Finite Automata
### Author: Maxim Alexei
----
## Theory:
****
&ensp;&ensp;&ensp; Parsing is a crucial phase in the processing of formal languages where the linear input sequence (often a string of tokens from a lexical analyzer) is transformed into a structured representation according to a formal grammar. This process serves as a bridge between lexical analysis and semantic analysis in compiler design.

&ensp;&ensp;&ensp; The parser's primary role is to determine if an input string can be derived from the grammar's start symbol by applying the grammar's production rules. Simultaneously, it constructs a representation of this derivation, typically in the form of a tree structure.
#### Types of Parsing Approaches

&ensp;&ensp;&ensp; Parsing techniques can be broadly categorized into two main approaches:
##### Top-Down Parsing
&ensp;&ensp;&ensp; Top-down parsers begin with the grammar's start symbol and attempt to derive the input string by expanding non-terminals according to the grammar rules. Common top-down parsing methods include:
- **Recursive Descent Parsing**: A direct implementation of the grammar as a set of mutually recursive procedures. Each non-terminal in the grammar corresponds to a procedure.
- **LL Parsing**: A table-driven approach where "LL" stands for Left-to-right scanning of the input, constructing a Leftmost derivation.

&ensp;&ensp;&ensp; Top-down parsers are generally more intuitive to implement and debug, making them popular for hand-written parsers.
##### Bottom-Up Parsing
&ensp;&ensp;&ensp; Bottom-up parsers start with the input string and attempt to reduce it to the grammar's start symbol by applying the grammar rules in reverse. Key bottom-up parsing techniques include:

- **LR Parsing**: A table-driven method where "LR" stands for Left-to-right scanning of the input, constructing a Rightmost derivation in reverse.
- **Shift-Reduce Parsing**: A general strategy that shifts input symbols onto a stack and reduces them according to grammar rules.

&ensp;&ensp;&ensp; Bottom-up parsers can handle a wider class of grammars and are often generated automatically by parser generators like Yacc or Bison.
#### Abstract Syntax Trees (ASTs)
&ensp;&ensp;&ensp; An Abstract Syntax Tree (AST) is a tree representation of the syntactic structure of the source code, abstracted from the concrete syntax details. Unlike a parse tree (which reflects every rule application in the grammar), an AST focuses on the essential structural elements and logical relationships.

Key characteristics of ASTs include:
- **Hierarchical Structure**: Represents the nested structure of programming constructs.
- **Abstraction**: Omits syntactic details like parentheses, semicolons, or other tokens that don't affect the meaning.
- **Node Types**: Typically has different node types for different language constructs (expressions, statements, declarations, etc.).

Considering the expression `3 * (4 + 5)`. A simplified AST might look like:

```
    *
   / \
  3   +
     / \
    4   5
```

&ensp;&ensp;&ensp; This representation captures the essential computational structure without concerning itself with details like parentheses.

#### Parsing and AST Construction

The construction of an AST is typically integrated with the parsing process:
1. **During Parsing**: As the parser recognizes language constructs, it builds corresponding AST nodes.
2. **Post-Parsing**: Some parsers first build a concrete parse tree, which is then transformed into an AST in a separate step.

The integration of AST construction with parsing requires careful design to ensure that:
- The AST correctly represents the semantics of the input program
- The node structure facilitates subsequent compilation phases
- Error handling and recovery are effective
#### Applications in Compiler Design
ASTs serve as the foundation for several critical phases in compilation:
- **Semantic Analysis**: Type checking, scope resolution, and other semantic validations are performed by traversing the AST.
- **Optimization**: Code optimization techniques analyze and transform the AST to improve efficiency.
- **Code Generation**: The final executable code is generated by traversing the AST and emitting appropriate target code.

Additionally, ASTs are valuable in modern development tools for:
- Static code analysis
- Automated refactoring
- Source code transformation
- Programming language services (like autocompletion and documentation generation)
#### Visitor Pattern for AST Processing
&ensp;&ensp;&ensp; A common design pattern for processing ASTs is the Visitor pattern, which separates the AST structure from the operations performed on it. This approach:
- Allows adding new operations without modifying the AST node classes
- Facilitates maintaining type safety across diverse node types
- Enables structured traversal of the tree

The implementation consists of:
1. A `Visitor` interface declaring visit methods for each node type
2. AST nodes that accept visitors via an `accept` method
3. Concrete visitor implementations for specific operations
## Objectives:
****
1. Get familiar with parsing, what it is and how it can be programmed [1].
2. Get familiar with the concept of AST [2].
3. In addition to what has been done in the 3rd lab work do the following:
    1. In case you didn't have a type that denotes the possible types of tokens you need to:
        1. Have a type **_TokenType_** (like an enum) that can be used in the lexical analysis to categorize the tokens.
        2. Please use regular expressions to identify the type of the token.
    2. Implement the necessary data structures for an AST that could be used for the text you have processed in the 3rd lab work.
    3. Implement a simple parser program that could extract the syntactic information from the input text.

## Implementation description
****
##### The logic within the `Program.cs`
&ensp;&ensp;&ensp; The main program orchestrates the testing framework for my parser implementation. It begins by enumerating all files in the `TestInputs` directory through the `Directory.EnumerateFiles` method. This allows me to process multiple test files sequentially, evaluating the robustness of my parser across diverse program examples. For each file discovered, I apply a filter to process only those with the `.pixil` extension, which represents my domain-specific language files.

&ensp;&ensp;&ensp;  Within the processing loop, I first read the entire file content using `File.ReadAllText` and display it in the console. I then wrapped the core processing in a `try-catch` block to handle potential errors gracefully. The processing pipeline starts with the lexical analysis phase, where a `Tokenizer` instance breaks the input text into discrete tokens. Each token's details—including type, value, line number, and column position—are displayed to provide comprehensive insight into the tokenization process. This detailed view is particularly valuable when diagnosing syntax issues in the input program.

&ensp;&ensp;&ensp;  The parser phase follows, where I pass the generated token list to the `Parser` class, which constructs an Abstract Syntax Tree representation of the program. This transformation from linear tokens to a hierarchical structure is crucial for semantic analysis and potential code generation phases. To visualize the constructed AST, I utilize the `ASTPrinter` visitor implementation, which traverses the entire tree structure and generates a formatted string representation. This output clearly shows the nested relationships between program elements, making it easier to verify the parser's correctness. If any exceptions occur during this process, the error message is captured and displayed, providing immediate feedback about syntax or semantic issues in the input program.

```csharp
var testInputDir = Directory.EnumerateFiles("TestInputs");

foreach (var testInputFile in testInputDir)
{
    if (testInputFile.Contains(".pixil"))
    {
        string input = File.ReadAllText(testInputFile);
        Console.WriteLine("\n\n{0}", input);

        try
        {
            // Tokenization Process
            Tokenizer lexer = new Tokenizer(input);
            List<Token> tokens = lexer.Tokenize();

            Console.WriteLine("\nTokens, detailed view:");
            foreach (var token in tokens)
                Console.WriteLine($"{token.Type}: '{token.Value}' at line {token.Line}, column {token.Column}");

            // Parsing Process
            Parser parser = new Parser(tokens);
            ProgramNode ast = parser.Parse();

            // Print the AST
            ASTPrinter printer = new ASTPrinter();
            string astString = printer.Print(ast);
            Console.WriteLine("\nAbstract Syntax Tree:");
            Console.WriteLine(astString);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"\nError: {ex.Message}");
        }
    }
}
```

##### Implementation of the `ASTNodes`
&ensp;&ensp;&ensp;  In the implementation of my parser, I've designed a comprehensive Abstract Syntax Tree (AST) structure that represents the hierarchical nature of my domain-specific language. The foundation of this structure is the abstract `ASTNode` class, which serves as the base for all components in the tree. This class provides a virtual `Accept` method to support the visitor pattern, which is crucial for performing operations across different node types without modifying their structure. The `IASTVisitor` interface defines the contract for visitors, with each `Visit` method corresponding to a specific node type, ensuring type safety when traversing the tree.

&ensp;&ensp;&ensp;  My AST structure includes a variety of specialized node classes that represent the different language constructs. The `ProgramNode` acts as the root of the tree, containing a collection of `BlockNode` instances that represent code blocks enclosed in curly braces. For representing specific operations, I've implemented nodes such as `BatchDeclarationNode`, `ForEachNode`, `VariableDeclarationNode`, and `AssignmentNode`. The control flow structures are captured by `IfNode`, which can contain optional `ElifBranchNode` instances and an `ElseBranch`. Image manipulation operations are represented by specialized nodes like `SetFilterNode`, `RotateNode`, and `CropNode`, which encapsulate the specific parameters needed for these operations.

&ensp;&ensp;&ensp;  For handling expressions, I've created an abstract `ExpressionNode` class that extends `ASTNode`, serving as the base for expression-specific nodes. The `BinaryExpressionNode` represents operations with two operands and an operator, essential for arithmetic and comparison operations. Values and identifiers are represented by `LiteralNode` and `VariableReferenceNode` respectively, while `MetadataNode` handles the retrieval of image metadata such as width, height, filename, and size. Each concrete node class overrides the `Accept` method to invoke the appropriate `Visit` method on the provided visitor, completing the visitor pattern implementation and enabling operations such as AST printing, semantic analysis, or code generation to be added without modifying the node classes themselves.

```csharp
public abstract class ASTNode
{
    // ...
}

public interface IASTVisitor
{
    void Visit(ProgramNode node);
    void Visit(BlockNode node);
	// ...
    void Visit(MetadataNode node);
}

// Other AST Nodes ...

public class MetadataNode : ExpressionNode
{
    public string ImageIdentifier { get; set; }
    public TokenType MetadataType { get; set; }
    
    public override void Accept(IASTVisitor visitor)
    {
        visitor.Visit(this);
    }
}
```

##### Actual `Parser` & its Methods
&ensp;&ensp;&ensp; The core of my parsing solution is implemented in the `Parser` class, which transforms a sequence of tokens into a structured Abstract Syntax Tree (AST). The parser begins with a list of tokens generated by the lexer and maintains an internal position pointer to track progress through the token stream. I've implemented a recursive descent parsing approach, which closely mirrors the structure of my language grammar by using distinct methods for each non-terminal symbol. This technique makes the parser implementation intuitive and closely aligned with the formal grammar specification, where each parsing method corresponds to a production rule.

&ensp;&ensp;&ensp; For error handling, I've created a custom `SyntaxError` exception class that captures detailed information about parsing failures, including line and column numbers for precise error reporting. This approach allows me to provide meaningful feedback to users when their code contains syntax errors. The parser employs a combination of lookahead and context checking to validate tokens before consumption, throwing specific exceptions with descriptive messages when unexpected tokens are encountered. The `Consume` method plays a critical role in this process, either advancing the token position or reporting errors if the expected token isn't present.

&ensp;&ensp;&ensp; The statement parsing logic is implemented using a switch statement in the `ParseStatement` method, which dispatches to specialized methods based on the current token type. This design enables the parser to handle various language constructs including batch declarations, foreach loops, variable declarations, assignments, conditional statements, and image processing operations like filters, rotations, and crops. Each specialized parsing method implements the logic required to parse a specific language construct, building the appropriate AST node with all necessary information extracted from the token stream.

&ensp;&ensp;&ensp; Expression parsing is particularly sophisticated, implementing the operator precedence through a series of layered methods that enforce the correct evaluation order. The parsing hierarchy begins with `ParseExpression`, which calls `ParseComparisonExpression`, which in turn calls `ParseAdditiveExpression`, followed by `ParseMultiplicativeExpression`, and finally `ParsePrimaryExpression`. This approach naturally handles operator precedence without requiring a separate precedence table. For binary expressions, the parser uses a loop-based approach that builds left-associative trees by repeatedly applying operators with the same precedence level. Primary expressions, which include literals, variable references, parenthesized expressions, and metadata references, form the foundation of the expression hierarchy and are handled by specialized parsing methods that extract the relevant information and create the appropriate AST nodes.

```csharp
public class Parser
{
    private readonly List<Token> _tokens;
    private int _position;
    private Token CurrentToken => _position < _tokens.Count ? _tokens[_position] : null;

    public ProgramNode Parse()
    {
        var program = new ProgramNode();
        
        while (_position < _tokens.Count && CurrentToken.Type != TokenType.EOF)
        {
            var block = ParseBlock();
            if (block != null)
            {
                program.Blocks.Add(block);
            }
            // ...
        }
        return program;
    }

    private BatchDeclarationNode ParseBatchDeclaration()
    {
        // ...
        return new BatchDeclarationNode
        {
            Identifier = identifier,
            Path = path
        };
    }
    // Other nodes parsing ...
}
```

##### Printing the Tree using `ASTPrint`
&ensp;&ensp;&ensp; To visualize the Abstract Syntax Tree structure, I've implemented the `ASTPrinter` class, which leverages the Visitor pattern through the `IASTVisitor` interface. The core functionality is encapsulated in the `Print` method, which accepts any `ASTNode` and returns a formatted string representation of the entire subtree. The printer maintains proper hierarchical indentation using a simple but effective approach—tracking the current indentation level with an `_indent` field and applying the appropriate spacing before each line using the `AppendIndent` method. This indentation mechanism visually communicates the nesting relationships between nodes, making the AST structure immediately comprehensible when displayed.

&ensp;&ensp;&ensp; The implementation provides specialized `Visit` methods for each node type in the AST, ensuring appropriate formatting for different language constructs. For container nodes like `ProgramNode` and `BlockNode`, the visitor recursively traverses child nodes while properly managing indentation levels with `IncreaseIndent` and `DecreaseIndent` calls. For statement nodes such as `BatchDeclarationNode`, `ForEachNode`, and `IfNode`, the printer formats their specific properties and recurses into any child blocks. The expression handling is particularly elegant, with `BinaryExpressionNode` formatted with parentheses to clearly indicate precedence, and `LiteralNode` values rendered according to their specific types (adding quotes for strings, appending 'p' for pixel values, etc.).

&ensp;&ensp;&ensp; To improve readability and maintainability, I've implemented several helper methods that translate internal token types to their string representations. Methods like `GetTypeName`, `GetFilterName`, `GetDirectionName`, `GetMetadataTypeName`, and `GetOperatorSymbol` encapsulate the mapping between the `TokenType` enum values and their human-readable equivalents. This design allows the AST printer to produce clear and consistent output without cluttering the core `Visit` methods with repetitive switch statements. By separating these concerns, the code remains focused and adaptable to future extensions of the language, as new token types will only require updates to these helper methods rather than modifications throughout the visitor implementation.

```csharp
public class ASTPrinter : IASTVisitor
{
    private StringBuilder _sb = new StringBuilder();
    private int _indent = 0;
    
    public string Print(ASTNode node)
    {
        _sb.Clear();
        _indent = 0;
        
        node.Accept(this);
        
        return _sb.ToString();
    }

	// Other printing functions ...
    
    private string GetOperatorSymbol(TokenType type)
    {
        switch (type)
        {
            case TokenType.PLUS: return "+";
            // ...
            case TokenType.SMALLER_EQUAL: return "<=";
            default: return type.ToString();
        }
    }
}
```

## Conclusions / Screenshots / Results
****
&ensp;&ensp;&ensp; In this section, besides the conclusion that gets described at the end, an example of output, resulted from the execution of the program, is also explained in-depth. 

```
{
    BATCH #rawImages = "C:/raw/";
    FOREACH IMG $img IN #rawImages {
        INT $width = METADATA $img FWIDTH;
        INT $height = METADATA $img FHEIGHT;

        CROP $img (1920, 1080);

        DOUBLE $fileSize = METADATA $img FSIZE;
        IF $fileSize > 10000 {
            SET $img NEGATIVE;
        }
        ELSE {
            SET $img SEPIA;
        }

        IF $height > $width {
            ROTATE $img RIGHT;
        }
    }
}

Abstract Syntax Tree:
Program:
  Block:
    BatchDeclaration: #rawImages = "C:/raw/"
    ForEach: $img in #rawImages
      Block:
        VariableDeclaration: INT $width = METADATA $img FWIDTH
        VariableDeclaration: INT $height = METADATA $img FHEIGHT
        Crop: $img (1920, 1080)
        VariableDeclaration: DOUBLE $fileSize = METADATA $img FSIZE
        If: ($fileSize > 10000)
          Block:
            SetFilter: $img NEGATIVE
        Else:
          Block:
            SetFilter: $img SEPIA
        If: ($height > $width)
          Block:
            Rotate: $img RIGHT
```

&ensp;&ensp;&ensp; In this laboratory work, I've successfully implemented a parser and Abstract Syntax Tree for my domain-specific language focused on image processing. Starting from a formal grammar definition, I designed a recursive descent parser that constructs a hierarchical representation of programs written in my DSL. This implementation included a comprehensive set of AST node classes to represent various language constructs such as batch declarations, foreach loops, conditional statements, and image manipulation operations. The parser correctly handles the translation from a linear sequence of tokens to a structured tree representation, preserving the semantic relationships between language elements and enforcing the syntactic rules defined in my grammar.

&ensp;&ensp;&ensp; The implementation of the visitor pattern proved to be particularly valuable, providing a flexible mechanism for traversing and operating on the AST without modifying the node classes themselves. This design choice facilitates future extensions to the language processor, allowing new operations to be added by simply implementing additional visitors. The ASTPrinter visitor demonstrates this flexibility, generating a human-readable representation of the parse tree that clearly shows the nested structure of the program. The test cases demonstrate that the parser correctly handles various language constructs, producing appropriate AST structures for different input programs.

&ensp;&ensp;&ensp; One of the more challenging aspects of this work was designing the expression parsing logic to correctly handle operator precedence. By implementing a hierarchy of parsing methods that mirror the precedence rules, I was able to ensure that expressions are correctly represented in the AST. Another challenge was implementing robust error handling that provides meaningful feedback when syntax errors are encountered. The custom SyntaxError exception class, combined with detailed error messages that include line and column information, provides valuable debugging information when parsing fails.

&ensp;&ensp;&ensp; Therefore, through this laboratory work, I've gained a deeper understanding of parsing techniques and the role of Abstract Syntax Trees in language processing. The implementation demonstrates how formal grammars can be translated into practical parser implementations, and how recursive descent parsing provides an intuitive approach that closely mirrors the structure of the language grammar. The AST structure provides a solid foundation for future enhancements, such as semantic analysis, optimization, or code generation for my domain-specific language. By applying concepts from formal languages and compiler design, I've created a robust parser that can analyze programs written in my image processing DSL, setting the stage for further development of the language processor.

## References
****

<a id="ref3"></a>[1] Parsing - Wikipedia - 
https://en.wikipedia.org/wiki/Parsing

<a id="ref4"></a>[2] Abstract syntax tree - Wikipedia - 
https://en.wikipedia.org/wiki/Abstract_syntax_tree

